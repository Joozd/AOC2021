package common.dijkstra

import common.extensions.printLines
import java.util.*
import kotlin.system.measureNanoTime

/**
 * Find routes using the Dijkstra algorithm.
 * @param nodeRetriever: Use this to retrieve nodes generated by nodes' getNeighbors() function.
 *  If null, neighbors will be used as they are.
 * @param expectedAMountOfNodes: The expected amount of nodes
 *  giving this a somewhat accurate value makes searching more efficient due to hashing reasons.
 */
class Dijkstra<T: Comparable<T>>(private val expectedAMountOfNodes: Int = STANDARD_SIZE_OF_GRAPH, private var nodeRetriever: NodeRetriever<T>?) {
    //val benchmarks = LongArray(20){ 0L }
    private var mostRecentCompletedRoute: List<NodeDistanceAndPrevious>? = null

    fun findRoute(start: Node<T>, end: Node<T>): List<Node<T>>?{
        val visitedNodes = HashSet<Node<T>>(expectedAMountOfNodes)
        val nodesToVisit = HashSetWithGet<NodeDistanceAndPrevious>()
        val startNode = NodeDistanceAndPrevious(start, start.zero)
        nodesToVisit.add(startNode)

        while(nodesToVisit.isNotEmpty()){
            //println(nodesToVisit.size)
            //println("nodesToVisit: ${nodesToVisit.size}")
            //println("visitedNodes: ${visitedNodes.size}\n")
            // this is never null as we just checked nodesToVisit is not empty

            with(nodesToVisit.minByOrNull { it.distanceToHere }!!){
                if (this.node == end) {
                    mostRecentCompletedRoute = makeRoute(this)
                    return mostRecentCompletedRoute?.map { it.node }
                }

                nodesToVisit.remove(this)
                visitedNodes.add(this.node)

                getNeighbors(visitedNodes).forEach { completedNeighbor ->
                    nodesToVisit.replaceIf(completedNeighbor) {
                        it == null || it.distanceToHere > completedNeighbor.distanceToHere
                    }
                }

            }
        }
        return null
    }

    /**
     * Generate a Set of all reachable nodes from [start]
     * (pro-tip: only use this in finite networks)
     */
    fun findAllReachableNodes(start: Node<T>): Set<Node<T>>{
        val foundNodes = HashSet<Node<T>>()
        val visitingNodes = HashSet<Node<T>>()
        visitingNodes.add(start)
        while(visitingNodes.isNotEmpty()){
            with(visitingNodes.first()){
                visitingNodes.remove(this)
                foundNodes.add(this)
                visitingNodes.addAll(this.getUnvisitedNeighborNodes(foundNodes))
            }
        }
        return foundNodes
    }

    /**
     * Find distance from [start] to [end]
     */
    fun findDistance(start: Node<T>, end: Node<T>): T?{
        findRoute(start, end)
        return getFoundDistance()
    }

    fun getFoundDistance(): T? = mostRecentCompletedRoute?.last()?.distanceToHere
/*
    fun printBenchmarks(){
        println(benchmarks.mapIndexed{index, it -> "$index: ${it/1000000}ms"}.printLines())
    }

 */


    private fun makeRoute(endpoint: NodeDistanceAndPrevious): List<NodeDistanceAndPrevious>{
        val route = LinkedList<NodeDistanceAndPrevious>()
        var currentPoint: NodeDistanceAndPrevious? = endpoint
        while (currentPoint != null){
            route.add(currentPoint)
            currentPoint = currentPoint.previousNode
        }
        return route.reversed()
    }

    private fun getNode(node: Node<T>) = if (nodeRetriever == null) node else nodeRetriever!![node]

    /**
     * Function to retrieve nodes from some place. Can invalidate nodes by making them null.
     */
    fun interface NodeRetriever<T: Comparable<T>> {
        operator fun get(node: Node<T>): Node<T>?
    }



    private inner class NodeDistanceAndPrevious(
        val node: Node<T>,
        val distanceToHere: T,
        val previousNode: NodeDistanceAndPrevious? = null
    ){
        override fun equals(other: Any?) = if (other !is Dijkstra<*>.NodeDistanceAndPrevious) false else node == other.node
        override fun hashCode() = node.hashCode()
        override fun toString() = "$node / d=$distanceToHere, p = ${previousNode?.node}"

        /**
         * get neighbors and put them in complete NodeDistanceAndPrevious objects
         */
        fun getNeighbors(visitedNodes: Set<Node<T>>): List<NodeDistanceAndPrevious> =
             node.getUnvisitedNeighborNodes(visitedNodes)
                .map { neighbor ->
                    NodeDistanceAndPrevious(
                        node = neighbor,
                        distanceToHere = node.addDistances(distanceToHere, node.getDistanceToNeighbor(neighbor)),
                        previousNode = this
                    )
                }
    }

    /**
     * Get the neighbor nodes that are unvisited and retrieve them from [getNode]
     */
    private fun Node<T>.getUnvisitedNeighborNodes(visitedNodes: Set<Node<T>>) =
        getNeighbors().filter { it !in visitedNodes }
            .mapNotNull { refNode -> getNode(refNode) }

    /*
    private inline fun <T> measureTime(index: Int, block: () -> T): T{
        var result: T
        val time = measureNanoTime { result = block() }
        benchmarks[index] += time
        return result
    }
    */


    companion object{
        private const val STANDARD_SIZE_OF_GRAPH = 10000
        /*
        const val INDEX_CHECK_IF_END = 0
        const val INDEX_CHECK_REMOVE_FROM_TO_VISIT_LIST = 1
        const val INDEX_ADD_TO_VISITED_LIST = 2
        const val INDEX_GET_NEIGHBORS = 3
        const val INDEX_CREATE_NEW_NODE = 4
        const val INDEX_LOOKUP_NODE = 5
        const val INDEX_CHECK_ADD_NEW_NODES_TO_VISITING_LIST = 6
        const val INDEX_CHECK_IF_NEIGHBOR_VISITED = 7
        const val INDEX_FIND_LOWEST_VISITING_NODE = 8
        */
    }
}